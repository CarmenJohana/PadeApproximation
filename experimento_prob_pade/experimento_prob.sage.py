

# This file was *autogenerated* from the file experimento_prob.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_5 = Integer(5); _sage_const_20 = Integer(20)
from numpy import mean
import csv

from sage.all import *

# ---------- Utilidades ----------
def rev_d(poly, d):
    """Reverso de grado d de un polinomio."""
    R = poly.parent()
    x = R.gen()
    coeffs = [poly[i] for i in range(d+_sage_const_1 )]
    res = R.zero()
    for i, a in enumerate(coeffs):
        res += a * x**(d - i)
    return res


def egcd_pade_canonico(R, pol1, pol2, k):
    
    f = R(pol1)
    g = R(pol2)
    inv_lc1= _sage_const_1 /f.leading_coefficient()
    inv_lc2 = _sage_const_1 /g.leading_coefficient()
    q = []
    i = _sage_const_1 
    r = [g*inv_lc2, f*inv_lc1]
    rho = [inv_lc2, inv_lc1]
    s = [R(_sage_const_1 /rho[_sage_const_0 ]), R(_sage_const_0 )]
    t = [R(_sage_const_0 ), R(_sage_const_1 /rho[_sage_const_1 ])]
    
    
    while not r[i].is_zero():
        
        qi, ri1 = r[i-_sage_const_1 ].quo_rem(r[i])
        q.append(qi) # q_i

        
        if ri1!=_sage_const_0 :
            lc = ri1.leading_coefficient()
            inv_lc = _sage_const_1  / lc 
        else:
            inv_lc = _sage_const_1 
        rho.append(inv_lc)
        
        
        r.append(ri1/rho[i+_sage_const_1 ]) # r_{i+1} = r_{i-1} - q_i r_i
        s.append((s[i-_sage_const_1 ] - qi*s[i])/rho[i+_sage_const_1 ])
        t.append((t[i-_sage_const_1 ] - qi*t[i])/rho[i+_sage_const_1 ])
       
        if ri1.degree() < k and t[i+_sage_const_1 ].degree() <= k and r[i+_sage_const_1 ].gcd(t[i+_sage_const_1 ]) == _sage_const_1 :
            tj = t[i+_sage_const_1 ]/(t[i+_sage_const_1 ].constant_coefficient())

            return ("ok", ri1, tj, i+_sage_const_1 )    
          
        i += _sage_const_1 
        
    return ("no", None, None, None)
        
def Pade_approximation_from_sequence(seq, n, F):
    """
    Calcula el polinomio minimal de una secuencia usando Padé (en lugar de Berlekamp–Massey).
    """
    R = PolynomialRing(F, 'x'); x = R.gen()
    f = R(list(seq))
    g = x**(_sage_const_2 *n)
    
   
    if f.is_zero():
        return ("no", "f es cero")
    res = egcd_pade_canonico(R, f, g, k=n)
    if res[_sage_const_0 ] != "ok":
        return ("no", "eea falló")
    _, rj, tj, j = res
    
    
    d = max(_sage_const_1  + Integer(rj.degree()), Integer(tj.degree()))
    m = rev_d(tj, d)
    return ("ok", m)


N = list(range(_sage_const_3 ,_sage_const_5 ))

for n in N:
    probs = []
    Q_vals = list(primes(_sage_const_5 , _sage_const_20 ))

    for q in Q_vals:
        res = []
        #x = polygen(F)
        F = Zmod(q)
        U = VectorSpace(F, n)
        for i in range(_sage_const_20 ):

            while True:
                A = random_matrix(F, n, n)
                b = random_vector(F,n)
                f,_ = A.cyclic_subspace(b, var="x", basis="iterates")
                if f.degree()==n:
                    break

            u = U.random_element()
            status, m = Pade_approximation_from_sequence([u*(A**j)*b for j in range(_sage_const_2 *n)], n, F)
            if status == "ok":
                res.append(int(f == m))
            else:
                res.append(_sage_const_0 )


        probs.append(mean(res))

    with open(f"datos/datos_prob{n}.csv", "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(["q", "prob"])
        for a,b in zip(Q_vals, probs):
            writer.writerow([a,b])

