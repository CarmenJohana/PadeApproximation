Wiedemann(A matrix A in F^{nxn}, vector b in F^{n})
	1. if b=0 then return 1
	2. choose a finite set U content in F
	3. choose u in U^n uniformly at ranom and compute u^TA^ib in F for 0<=i<2n
	4. call the algorithm of Padé approximation to compute the minimal polynomial
	m in F[x] of the linearly recurrent sequence (u^T A^i b)_{i in Natural numbers} in F^{Natural numbers},
	with recursion bound n
	5. if m(A)b=0 in F^{n} then return m else goto 3

Pade_Approximation(n, n):
	do The Extended Eucledian Algorithm 3.14 of the image for g=x^{2n} and f=a_{2n-1}x^{2n-1} + ... + a_1x + a_0 (here, the a_i elements are the terms of the sequence (u^T A^i b)_{i in Natural numbers})
	if in the final gcd(s,t)=1 and that x doesn't divide t and h is congruent with (s/t) mod x^{2n} for that first j-th row where deg s<n and degt<=n
		d <- max{1+deg s, deg t}
		return rev_d(t)
	else
		return "There's no (n,n)-Pade Approximation" 

An observation: The reverse of a polynomial for f = f_d x^d + ... f_0 in F[x] of degree, we have

	rev(f) = rev_d(f) = f_0 x^d + f_1 x^{d-1} + ... + f_d in F[x] 
	


from sage.all import *

# ---------- utilidades ----------
def rev_d(poly, d):
    """Reverso de grado d de un polinomio."""
    R = poly.parent()
    x = R.gen()
    coeffs = [poly.coefficient(i) for i in range(d+1)]
    res = R.zero()
    for i, a in enumerate(coeffs):
        res += a * x**(d - i)
    return res

'''
def egcd_pade_canonico(R, pol_f, pol_g, k):
    """
    Extended Euclidean Algorithm canónico para Padé sobre R = GF(p)[x].
    Normaliza t(0)=1 cuando es posible.
    """
    f = R(pol_f)
    g = R(pol_g)

    if f.is_zero() or g.is_zero():
        raise ValueError("f y g deben ser no nulos.")

    inv_lc_f = 1 / f.leading_coefficient()
    inv_lc_g = 1 / g.leading_coefficient()

    r = [f * inv_lc_f, g * inv_lc_g]
    s = [R(inv_lc_f), R(0)]
    t = [R(0), R(inv_lc_g)]

    i = 1
    while True:
        if r[i].is_zero():
            j = i - 1
        elif r[i].degree() < k:
            j = i
        else:
            qi, ri1 = r[i-1].quo_rem(r[i])
            si1 = s[i-1] - qi * s[i]
            ti1 = t[i-1] - qi * t[i]
            if not ri1.is_zero():
                inv_lc = 1 / ri1.leading_coefficient()
                ri1 *= inv_lc
                si1 *= inv_lc
                ti1 *= inv_lc
            r.append(ri1)
            s.append(si1)
            t.append(ti1)
            i += 1
            continue

        rj, tj = r[j], t[j]
        if rj.gcd(tj) == 1:
            if not tj(0).is_zero():
                inv_t0 = 1 / tj(0)
                rj *= inv_t0
                tj *= inv_t0
            tau = tj.leading_coefficient()
            return ("ok", rj / tau, tj / tau, j)
        else:
            return ("unsat", rj, tj, j)
'''



def egcd_pade_canonico(R, pol1, pol2, k):
    
    #R = PolynomialRing(Zmod(q), 'x')
    f = R(pol1)
    g = R(pol2)
    inv_lc1= 1/f.leading_coefficient()
    inv_lc2 = 1/g.leading_coefficient()
    
    r = [f*inv_lc1, g*inv_lc2,]

    q = []
    i = 1
    rho = [inv_lc1, inv_lc2]
    s = [R(1/rho[0]), R(0)]
    t = [R(0), R(R(1)/R(rho[1]))]
    
    while not r[i].is_zero():
        
        
        qi, ri1 = r[i-1].quo_rem(r[i])
        
        q.append(qi) # q_i
        
        
        if ri1!=0:
            lc = ri1.leading_coefficient()
            inv_lc = 1 / lc
            ri1 *= inv_lc
            
        else:
            inv_lc = 1
        rho.append(inv_lc)
        
        r.append(ri1) # r_{i+1} = r_{i-1} - q_i r_i
        #print(i, rho)
        s.append((s[i-1] - qi*s[i])*rho[i+1])    # s_{i+1} = s_{i-1} - q_i s_i
        t.append((t[i-1] - qi*t[i])*rho[i+1])    # t_{i+1} = t_{i-1} - q_i t_i
        i += 1
        
        print("r : ", r)
        print("t: ", t)
        
     
    return r, t


def Pade_approximation_from_sequence(seq, n, F):
    """
    Calcula el polinomio minimal de una secuencia usando Padé (en lugar de Berlekamp–Massey).
    """
    R = PolynomialRing(F, 'x'); x = R.gen()
    f = R(list(seq))
    g = x**(2*n)
    
    print("f: ",f, " and ", g) 
    if f.is_zero():
        return ("no", "f es cero")
    res = egcd_pade_canonico(R, f, g, k=n)
    if res[0] != "ok":
        return ("no", "eea falló")
    _, rj, tj, j = res
    
    print("t_j: ", tj)
    
    if tj % x == 0:
        return ("no", "x divide t_j")
    d = max(1 + Integer(rj.degree()), Integer(tj.degree()))
    m = rev_d(tj, d)
    return ("ok", m)


# ---------- Wiedemann ----------
def Wiedemann(A, b):
    """
    Implementación del algoritmo de Wiedemann con Padé para polinomio minimal.
    """
    if not A.is_square():
        raise ValueError("La matriz no es cuadrada.")
    if A.is_singular():
        raise ValueError("La matriz es singular (no tiene inversa).")

    F = A.base_ring()
    n = A.nrows()
    V = VectorSpace(F, n)

    y = V.random_element()
    while True:
        #u = V.random_element()
        u = vector(F, [1,0,0])
        v = b
        seq = [u.dot_product(v)]
        for i in range(1, 2*n):
            v = A * v
            seq.append(u.dot_product(v))
        print(seq)
        status, m = Pade_approximation_from_sequence(seq, n, F)
        
        print("m:", m)
        if status != "ok":
            continue  # vuelve a intentar con otro u

        # Si m(x) = c0 + c1 x + ... + ck x^k
        # definimos h(x) = (m(x) - m(0)) / (x * m(0))
        R = m.parent(); x = R.gen()
        h = (m - m(0)) / (x * m(0))

        y = h(A) * b
        if A * y == b:
            return y


# ---------- Ejemplo ----------
F = Zmod(5)
R = PowerSeriesRing(F, 'x')
V = VectorSpace(F, 2)
VV = MatrixSpace(F, 2, 2)
u = V.random_element()
A = matrix(F, [[1,4,4],[4,0,3],[1,2,4]])
b = vector(F, [3,1,2])
print(A)
print(b)
y = Wiedemann(A,b)
print(y)

print("A =\n", A)
print("b =", b)
y = Wiedemann(A, b)
print("Solución y =", y)
print("Verificación A*y =", A*y)
